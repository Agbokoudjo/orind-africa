TrÃ¨s bonne remarque ğŸ‘, tu touches Ã  un sujet central en DDD / clean architecture : **oÃ¹ placer les abstractions liÃ©es Ã  la messagerie (Mailer, Message, async)**.

---

### ğŸ“Œ Rappel des rÃ¨gles DDD

* La **couche Domain** ne doit pas dÃ©pendre de Symfony Mailer, Messenger, ni aucun framework.
* La **couche Application** orchestre les cas dâ€™usage (UseCases). Elle peut dire *"envoie un mail"* ou *"publie un message async"*, mais sans savoir **comment** Ã§a marche.
* La **couche Infrastructure** fait le vrai boulot : implÃ©menter le Mailer avec `Symfony\Component\Mailer`, envoyer le message dans RabbitMQ ou Doctrine, etc.

---

### ğŸ—ï¸ Organisation possible

#### 1. CrÃ©er une abstraction de mailer dans **Application**

ğŸ‘‰ Exemple :
`/src/Application/Service/MailerInterface.php`

```php
namespace App\Application\Service;

interface MailerInterface
{
    public function send(MailMessageInterface $message): void;
}
```

Et lâ€™abstraction du message :

```php
namespace App\Application\Service;

interface MailMessageInterface
{
    public function getSubject(): string;
    public function getBody(): string;
    public function getRecipients(): array;
}
```

#### 2. ImplÃ©mentation dans **Infrastructure**

ğŸ‘‰ Exemple :
`/src/Infrastructure/Mailer/SymfonyMailerAdapter.php`

```php
namespace App\Infrastructure\Mailer;

use App\Application\Service\MailerInterface;
use App\Application\Service\MailMessageInterface;
use Symfony\Component\Mailer\MailerInterface as SymfonyMailer;
use Symfony\Component\Mime\Email;

final class SymfonyMailerAdapter implements MailerInterface
{
    public function __construct(private SymfonyMailer $mailer) {}

    public function send(MailMessageInterface $message): void
    {
        $email = (new Email())
            ->to(...$message->getRecipients())
            ->subject($message->getSubject())
            ->text($message->getBody());

        $this->mailer->send($email);
    }
}
```

#### 3. Async avec Messenger

Si tu veux que lâ€™envoi se fasse en **asynchrone**, tu peux :

* DÃ©finir une commande / Ã©vÃ©nement dans Application (`UserRegisteredEvent`)
* Le publier dans un **EventBusInterface** (toujours Application)
* Lâ€™implÃ©menter avec **Messenger** dans Infrastructure.

---

### ğŸš€ RÃ©sumÃ© clair

* **Application** : dÃ©finit `MailerInterface`, `MailMessageInterface`, `EventBusInterface`
* **Domain** : ne connaÃ®t rien du mail, mais peut lever des Ã©vÃ©nements mÃ©tiers (`UserRegisteredEvent`)
* **Infrastructure** : implÃ©mente le Mailer (Symfony Mailer, AWS SES, Postmark, etc.) et le bus async (Messenger, RabbitMQ, Kafka).

---

ğŸ‘‰ Tu nâ€™as pas besoin de crÃ©er une nouvelle *couche* pour Ã§a.
Câ€™est de lâ€™**Infrastructure** pur, mais lâ€™abstraction reste dans **Application** pour que tes UseCases puissent lâ€™utiliser.

---

Veux-tu que je te montre un exemple complet de **UseCase `RegisterUser` qui envoie un mail de bienvenue via ton abstraction Mailer** ?

